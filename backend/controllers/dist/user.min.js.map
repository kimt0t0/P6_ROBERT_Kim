{"version":3,"sources":["user.js"],"names":["User","require","bcrypt","emailValidator","MaskData","passwordSchema","passwordValidator","is","min","has","uppercase","digits","spaces","exports","not","res","next","validate","req","body","email","password","status","json","message","maskEmail2","then","user","hash","error","login","findOne","compare","valid","userId","_id","token","sign","expiresIn"],"mappings":"aACA,IAAMA,KAAOC,QAAQ,kBADrBC,OAAAD,QAAA,UACMD,IAAOC,QAAQ,gBAGfE,eAAiBF,QAAQ,mBAFzBC,kBAAiBD,QAAvB,sBAIMG,SAAWH,QAAQ,YAEnBI,eAAiB,IAAIC,kBAJ3BD,eAOKE,KAAKC,IAAI,GANRF,GAAAA,IAAAA,IAQDG,MAAMC,YAPLN,MAAAA,YASDK,MAAME,SAPLN,MAAAA,MAAAA,UAENA,MAAAA,MAAAO,SAAAC,QAOWC,OAAMF,SAAAA,EAPjBG,EAAAC,GASA,IAAAb,eAAAc,SAAAC,EAAAC,KAAAC,SAAAf,eAAAY,SAAAC,EAAAC,KAAAE,UAIQ,OAAON,EAAIO,OAAO,KAAKC,KAAK,CAACC,QAAS,2OAErC,GAAIrB,eAAec,SAASC,EAAIC,KAAKC,QAAUf,eAAeY,SAASC,EAAIC,KAAKE,UAAW,CAJlFH,SAADO,WAAoBP,EAAAC,KAAAC,OAC5BjB,OAAAA,KAAAA,EAAec,KAAAA,SAAS,IACzBS,KAAWJ,SAAAA,GAA2B,IAAAtB,KAAA,CAAtCoB,MAAAA,MAEKjB,SAAAA,IAEOe,OAEFS,KAAO,SAAAC,GAAI5B,OAAMe,EAAAO,OAAA,KAAAC,KAAA,CAAAC,QAAA,wBAFpBI,MAGQR,SAAAA,GADY,OAAAL,EAAAO,OAAA,KAAAC,KAAA,CAAAM,MAAAA,QAP1B1B,MAOG,SAAA0B,GAAA,OAAAd,EAAAO,OAAA,KAAAC,KAAA,CAAAM,MAAAA,QAKUhB,QADViB,MAAA,SAAAZ,EAEOH,EAAAC,GAAKhB,KAAA+B,QAAIhB,CAAGK,MAAHF,EAAAC,KAAgBI,QAAMM,KAAAA,SAAAA,GAA1B,IAAAF,EAFZ,OAAAZ,EAAAO,OAAA,KAAAC,KAAA,CAIGC,QAAAK,wCAAK3B,OAAA8B,QAAAd,EAAAC,KAAAE,SAAAM,EAAAN,UAVZK,KAAA,SAAAO,GAWH,IAAAA,EAemB,OAAOlB,EAAIO,OAAO,KAAKC,KAAK,CAf/CC,QAAA,wCAmBeT,EAAIO,OAAO,KAAKC,KAAK,CACjBW,OAAQP,EAAKQ,IAhBrBC,MAAMrB,IAANsB,KACC,CAAAH,OAAAP,EAAAQ,KAAiBf,sBACZ,CAAAkB,UAAA,YAPF,MASJ,SAAAT,GAGHd,EAAAO,OAAA,KAAAC,KAAA,CAAAM,MAAAA,QAdW,MAiBCI,SAAAA,GAAO,OAAAlB,EAAAO,OAAA,KAAAC,KAAA,CAAAM,MAAAA","file":"user.min.js","sourcesContent":["/* VARIABLES */\r\nconst User = require('../models/User');\r\nconst bcrypt = require('bcrypt');\r\nconst jwt = require('jsonwebtoken'); //token generation\r\nconst emailValidator = require('email-validator');\r\nconst passwordValidator = require('password-validator');\r\nconst MaskData = require('maskdata');\r\n\r\nconst passwordSchema = new passwordValidator();\r\n\r\npasswordSchema\r\n    .is().min(8)  //min length\r\n    .is.max(50) //max length\r\n    .has().uppercase()  //must have...\r\n    .has().lowercase()\r\n    .has().digits()\r\n    .has().not().symbols() // must not have...\r\n    .has().not().spaces();\r\n\r\n/* FONCTIONS */\r\n/* Sign-Up */\r\nexports.signup = (req, res, next) => {\r\n    if (!emailValidator.validate(req.body.email) || !passwordSchema.validate(req.body.password)) {\r\n        return res.status(400).json({message: 'Veuillez vérifier le format de votre adresse e-mail ainsi que votre mot-de-passe. Il doit comporter minimum 8 caractères et contenir des minuscules, majuscules et chiffres. Les espaces et caractères spéciaux ne sont pas autorisés.'})\r\n    } \r\n    else if (emailValidator.validate(req.body.email) || passwordSchema.validate(req.body.password)) {\r\n        const maskedMail = MaskData.maskEmail2(req.body.email);\r\n        bcrypt.hash(req.body.password, 10)\r\n        .then (hash => {\r\n            const user = new User ({\r\n                email: email,\r\n                password: hash\r\n            });\r\n            user.save()\r\n            .then(hash => res.status(201).json({message: 'Utilisateur créé!'}))\r\n            .catch(error => res.status(400).json({error}))\r\n        })\r\n        .catch(error => res.status(500).json({error}))\r\n    };\r\n};\r\n\r\n/* Connexion */\r\nexports.login = (req, res, next) => {\r\n    User.findOne({email: req.body.email})\r\n        .then(user => {\r\n            if (!user) {\r\n                return res.status(401).json({\r\n                    message: 'Paire login/mot de passe incorrecte'\r\n                });\r\n            }\r\n            bcrypt.compare(req.body.password, user.password)\r\n                .then(valid => {\r\n                    if (!valid) {\r\n                        return res.status(401).json({\r\n                            message: 'Paire login/mot de passe incorrecte'\r\n                        });\r\n                    }\r\n                    res.status(200).json({\r\n                        userId: user._id,\r\n                        token: jwt.sign( // chiffrage nouveau token qui contient:\r\n                            {userId: user._id}, // id utilisateur\r\n                            'RANDOM_TOKEN_SECRET', // chaîne secrète de dev temporaire pour crypter le token\r\n                            {expiresIn: '24h'} // durée de validité\r\n                        )\r\n                    });\r\n                })\r\n                .catch(error => {\r\n                    res.status(500).json({error})\r\n                });\r\n        })\r\n        .catch(error => res.status(500).json({error}));\r\n};"]}