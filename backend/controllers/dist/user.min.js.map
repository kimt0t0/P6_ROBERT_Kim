{"version":3,"sources":["user.js"],"names":["bcrypt","require","User","emailValidator","MaskData","passwordSchema","passwordValidator","is","min","has","uppercase","digits","exports","lowercase","req","res","validate","body","email","password","status","json","message","maskedMail","maskEmail2","signup","hash","next","then","error","login","findOne","user","valid","userId","_id","token","jwt","sign","expiresIn"],"mappings":"aACA,IAAMA,OAASC,QAAQ,UADvBC,KAAAD,QAAA,kBACMD,IAAMC,QAAU,gBAGhBE,eAAiBF,QAAQ,mBAFzBC,kBAAeD,QAAA,sBAIfG,SAAWH,QAAQ,YAEnBI,eAAiB,IAAIC,kBAJ3BD,eAOKE,KAAKC,IAAI,GANRF,KAAAA,IAAAA,IAQDG,MAAMC,YAPLN,MAAAA,YASDK,MAAME,SAPLN,MAAAA,MAAAA,UAENO,QAIWC,OAJX,SAAAC,EAAAC,EAKWJ,GAMP,IAAKR,eAAea,SAASF,EAAIG,KAAKC,SAAWb,eAAeW,SAASF,EAAIG,KAAKE,UAHtF,OAAAJ,EAAAK,OAAA,KAAAC,KAAA,CAAAC,QAAA,2OACA,GAAAnB,eAAAa,SAAAF,EAAAG,KAAAC,QAAAb,eAAAW,SAAAF,EAAAG,KAAAE,UAAA,CAMQ,IAAMI,EAAanB,SAASoB,WAAWV,EAAIG,KAAKC,OALhDO,OAARC,KAAiBZ,EAAAG,KAACH,SAAUa,IACnBxB,KAAAA,SAAAA,GACM,IAAgBkB,KAAK,CAAUH,MAAAK,EAAtCJ,SAAAO,IAGMH,OACCG,KAAKZ,SAAAA,GAAIG,OAAKE,EAAAA,OAArB,KACCS,KAAM,CAAAN,QAAAI,wBAFDH,MAGW,SAAAM,GAAI3B,OAAMa,EAAAK,OAAA,KAAAC,KAAA,CAAAQ,MAAAA,QAR3BJ,MAUQN,SAAAA,GAAUO,OAAAA,EAAAA,OAAAA,KAAAA,KAAAA,CAAAA,MAAAA,QAGqBd,QAAAkB,MAAzB,SAAAhB,EAAAC,EAAAY,GAAA,IADVJ,EAEOnB,SAAAyB,WAAKf,EAAAG,KAAAC,OAAAhB,KAAA6B,QAAIhB,CAAGG,MAAHK,IAAsBM,KAAAA,SAAAA,GAAD,IAAzBG,EAFZ,OAAAjB,EAAAK,OAAA,KAAAC,KAAA,CAAAQ,MAAA,4BAIQ7B,OAAIe,QAAAD,EAAAG,KAAgBI,SAAKW,EAAAb,UAACU,KAAAA,SAAAA,GAA1B,IAAAI,EAVZ,OAAAlB,EAAAK,OAAA,KAAAC,KAAA,CAAAQ,MAAA,4BA2BId,EAAIK,OAAO,KAAKC,KAAK,CAhB5Ba,OAAAF,EAAAG,IAjBLC,MAAAC,IAAAC,KAoBA,CAAAJ,OAAAF,EAAAG,KAiBoB,sBACA,CAACI,UAAW,YAtBZ,MAOKhB,SAAAA,GAAAA,OAAAA,EAAAA,OAAAA,KAAAA,KAAAA,CAAAA,MAAAA,QATD,MAUd,SAAAM,GAAA,OAAAG,EAAQZ,OAAA,KAAAC,KAAA,CAAAQ,MAAAA","file":"user.min.js","sourcesContent":["/* VARIABLES */\r\nconst bcrypt = require('bcrypt');\r\nconst User = require('../models/User');\r\nconst jwt = require('jsonwebtoken'); //token generation\r\nconst emailValidator = require('email-validator');\r\nconst passwordValidator = require('password-validator');\r\nconst MaskData = require('maskdata');\r\n\r\nconst passwordSchema = new passwordValidator();\r\n\r\npasswordSchema\r\n    .is().min(8)  //min length\r\n    .is().max(50) //max length\r\n    .has().uppercase()  //must have...\r\n    .has().lowercase()\r\n    .has().digits()\r\n    .has().not().symbols(); // must not have...\r\n\r\n/* FONCTIONS */\r\n/* Sign-Up */\r\nexports.signup = (req, res, next) => {\r\n    if (!emailValidator.validate(req.body.email) || !passwordSchema.validate(req.body.password)) {\r\n        return res.status(400).json({message: 'Veuillez vérifier le format de votre adresse e-mail ainsi que votre mot-de-passe. Il doit comporter minimum 8 caractères et contenir des minuscules, majuscules et chiffres. Les espaces et caractères spéciaux ne sont pas autorisés.'})\r\n    } \r\n    else if (emailValidator.validate(req.body.email) || passwordSchema.validate(req.body.password)) {\r\n        const maskedMail = MaskData.maskEmail2(req.body.email);\r\n        bcrypt.hash(req.body.password, 10)\r\n        .then (hash => {\r\n            const user = new User ({\r\n                email: maskedMail,\r\n                password: hash\r\n            });\r\n            user.save()\r\n            .then(hash => res.status(201).json({message: 'Utilisateur créé!'}))\r\n            .catch(error => res.status(400).json({error}))\r\n        })\r\n        .catch(error => res.status(500).json({error}))\r\n    };\r\n}\r\n\r\n/* Log-in */\r\nexports.login = (req, res, next) => {\r\n    const maskedMail = MaskData.maskEmail2(req.body.email);\r\n    User.findOne({email: maskedMail}) // check if the email address is in the data-base\r\n    .then(user => {\r\n        if(!user) {\r\n            return res.status(401).json({error: 'Utilisateur non trouvé!'});\r\n        }\r\n        bcrypt.compare(req.body.password, user.password) //compares the hashes\r\n        .then (valid => {\r\n            if (!valid) {\r\n                return res.status(401).json({error: 'Mot de passe incorrect!'});\r\n            }\r\n            res.status(200).json({\r\n                userId: user._id,\r\n                token: jwt.sign(\r\n                    {userId: user._id},\r\n                    'RANDOM_TOKEN_SECRET',\r\n                    {expiresIn: '24h'}\r\n                )\r\n            })\r\n        })\r\n        .catch(error => res.status(500).json({error}));\r\n    })\r\n    .catch(error => res.status(500).json({error}));\r\n};"]}